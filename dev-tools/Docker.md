Docker revolutionized software development and deployment by introducing containerization, which offers several key advantages:

- **Isolation**: Containers encapsulate applications and their dependencies, ensuring they run consistently across different environments without interference.

- **Environment Consistency**: By packaging applications with their specific dependencies, Docker ensures uniform behavior across development, testing, and production stages.

- **Speed**: Containers are lightweight and share the host system's kernel, allowing for rapid startup times and efficient resource utilization.

**Evolution of Docker Command-Line Interface**

Docker's command-line interface (CLI) has evolved to enhance usability and clarity:

- **Previous Syntax**: Commands were executed directly, such as `docker run` or `docker build`.

- **Current Syntax**: Docker adopted a more structured approach with subcommands, improving organization and readability. For example:

  - **Old**: `docker run`

  - **New**: `docker container run`

  - **Old**: `docker build`

  - **New**: `docker image build`

This change aligns with Docker's emphasis on clarity and modularity in command structures.

**Dockerfile**

A Dockerfile is a script containing a series of instructions to assemble an image. Its syntax has become a standard for container configurations, as recognized by the [Open Container Initiative (OCI)](https://opencontainers.org).

**.dockerignore**

The `.dockerignore` file specifies files and directories that should be excluded from the build context, optimizing the build process by preventing unnecessary files from being sent to the Docker daemon.

**Layering**

Docker images are constructed in layers, with each instruction in a Dockerfile adding a new layer. This layering enables efficient storage and transfer, as unchanged layers can be reused across different images.

**Volumes**

Volumes are used to persist data generated by and used by Docker containers. They allow data to exist independently of the container's lifecycle.

Example:

```bash
sudo docker run --name sampleapp_1 -v $(pwd):/app -v /app/node_modules -p 3232:3232 sampleapp
```

In this command:

- `-v $(pwd):/app` mounts the current directory to `/app` in the container.

- `-v /app/node_modules` creates a volume for the `node_modules` directory.

- `-p 3232:3232` maps port 3232 of the host to port 3232 of the container.

**Pruning**

Over time, Docker can accumulate unused data, such as stopped containers, unused images, and networks. Docker provides pruning commands to clean up these resources:

- **Remove stopped containers**:

  ```bash
  docker container prune
  ```

- **Remove unused images**:

  ```bash
  docker image prune
  ```

- **Remove unused networks**:

  ```bash
  docker network prune
  ```

- **Remove unused volumes**:

  ```bash
  docker volume prune
  ```

- **Remove all unused resources**:

  ```bash
  docker system prune
  ```

Regular pruning helps maintain a clean and efficient Docker environment.


### CLI Process monitoring
- `container top` - list out all the process
- `container inspect` - details of one container config
- `container stats` - performance stats for all containers

### Getting a shell Inside Cointainers
- `container run -it` - start new container interactively
- `container exec-it container program` - run additional command in existing container
- `container start -ai ` - for stopped container

> `-t` flag is for pseudo-tty
> `-i` for interactive



